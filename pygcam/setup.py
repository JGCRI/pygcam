'''
.. gcamtool plugin for setting up / customizing GCAM project's XML files.

.. codeauthor:: Rich Plevin <rich@plevin.com>

.. Copyright (c) 2016 Richard Plevin
   See the https://opensource.org/licenses/MIT for license details.
'''

import os
import shutil
from importlib import import_module

from .config import getParam, getParamAsBoolean
from .constants import LOCAL_XML_NAME, DYN_XML_NAME
from .error import SetupException
from .log import getLogger
from .subcommand import SubcommandABC
from .utils import loadModuleFromPath, copyFileOrTree, removeFileOrTree, mkdirs, pushd
from .windows import removeSymlink

pathjoin = os.path.join

_logger = getLogger(__name__)

# Deprecated?
def jobTmpDir():
    '''
    Generate the name of a temporary directory based on the value of GCAM.TempDir
    and the job ID from the environment.
    '''
    tmpDir = getParam('GCAM.TempDir')
    dirName = "mcs.%s.tmp" % 999999 # TBD: getJobNum()
    dirPath = pathjoin(tmpDir, dirName)
    return dirPath

#
# TBD: fix this and call it from setupWorkspace if mcs == True
#
def _setupTempOutputDir(outputDir):
    removeFileOrTree(outputDir, raiseError=False)

    if getParamAsBoolean('GCAM.MCS.UseTempOutput'): # TBD: define this variable
        dirPath = jobTmpDir()
        shutil.rmtree(dirPath, ignore_errors=True)  # rm any files from prior run in this job
        mkdirs(dirPath)
        _logger.debug("Creating '%s' link to %s" % (outputDir, dirPath))

        #TBD: workspaceSymlink(dirPath, output, relative=False)

        # Create a link that the epilogue.py script can find.
        if getParam('Core.Epilogue'):
            pass # TBD: createEpilogueLink(dirPath)
    else:
        mkdirs(outputDir)

def _remakeSymLink(source, linkname):
    if os.path.islink(linkname):
        removeSymlink(linkname)
    os.symlink(source, linkname)


# Deprecated?
# Add symlinks to (or copy) dirs holding files generated by "setup" scripts
def _linkOrCopyXmlDir(src, runWorkspace):
    leafName = os.path.basename(os.path.normpath(src))     # normpath loses any trailing slash
    dst = os.path.abspath(pathjoin(runWorkspace, leafName))

    if os.path.islink(dst):
        removeSymlink(dst)

    if getParamAsBoolean('GCAM.CopyAllFiles'):
        # for Windows users without symlink permission
        _logger.info('Copying %s to %s' % (src, dst))
        shutil.copytree(src, dst)
    else:
        _remakeSymLink(src, dst)


def _workspaceLinkOrCopy(src, srcWorkspace, dstWorkspace, copyFiles=False):
    '''
    Create a link (or copy) in the new workspace to the
    equivalent file in the given source workspace.
    '''
    # Set automatically on Windows for users without symlink permission
    copyFiles = copyFiles or getParamAsBoolean('GCAM.CopyAllFiles')
    linkFiles = not copyFiles

    if os.path.isabs(src):
        # if absolute path, append only the basename to the runWorkspace
        srcPath = src
        dstPath = pathjoin(dstWorkspace, os.path.basename(os.path.normpath(src)))
    else:
        # if relative path, append the whole thing to both workspaces
        srcPath = pathjoin(srcWorkspace, src)
        dstPath = pathjoin(dstWorkspace, src)

    # Ensure that parent directory exists
    parent = os.path.dirname(dstPath)
    mkdirs(parent)

    # If dstPath is a link, we always remove it and either recreate
    # the link or copy the files as required. If dstPath isn't a
    # link, we remove it only if we are replacing it with a link.
    if os.path.lexists(dstPath) and (linkFiles or os.path.islink(dstPath)):
        removeFileOrTree(dstPath)

    # We've removed dstPath unless we're avoiding re-copying srcPath
    if not os.path.lexists(dstPath):
        if copyFiles:
            _logger.info('Copying %s to %s' % (srcPath, dstPath))
            copyFileOrTree(srcPath, dstPath)
        else:
            os.symlink(srcPath, dstPath)


def createSandbox(sandbox, srcWorkspace=None, forceCreate=False, mcsMode=''):
    '''
    Set up a run-time sandbox in which to run GCAM. This involves copying
    from or linking to files and directories in `workspace`, which defaults
    to the value of config parameter GCAM.RunWorkspace.

    :param sandbox: (str) the directory to create
    :param srcWorkspace: (str) the workspace to link to or copy from
    :param forceCreate: (bool) if True, delete and recreate the sandbox
    :param mcsMode: (bool) if True, perform setup appropriate for gcammcs trials.
    :return: none
    '''
    srcWorkspace = srcWorkspace or getParam('GCAM.SandboxRefWorkspace')

    # MCS "new" sub-command creates its ref workspace; for non-MCS
    # we do it on demand, i.e., if it doesn't exist already.
    if not mcsMode and not os.path.lexists(srcWorkspace):
        copyWorkspace(srcWorkspace)

    if mcsMode and getParamAsBoolean('GCAM.CopyAllFiles'):
        _logger.warn('GCAM.CopyAllFiles = True while running MCS')

    _logger.info("Setting up sandbox '%s'", sandbox)

    if os.path.lexists(sandbox) and os.path.samefile(sandbox, srcWorkspace):
        raise SetupException("run sandbox is the same as run workspace; no setup performed")

    if forceCreate:
        shutil.rmtree(sandbox, ignore_errors=True)

    # also makes sandbox and sandbox/exe
    logPath = pathjoin(sandbox, 'exe', 'logs')
    mkdirs(logPath)

    toCopy = getParam('GCAM.SandboxFilesToCopy')
    for filename in toCopy.split():
        _workspaceLinkOrCopy(filename, srcWorkspace, sandbox, copyFiles=True)

    toLink = getParam('GCAM.SandboxFilesToLink')
    for filename in toLink.split():
        _workspaceLinkOrCopy(filename, srcWorkspace, sandbox, copyFiles=False)

    outputDir = pathjoin(sandbox, 'output')

    if mcsMode:
        # link {sandbox}/dyn-xml to ../dyn-xml
        dynXmlDir = pathjoin('..', DYN_XML_NAME)
        mkdirs(dynXmlDir)

        # deal with link and tmp dir...
        _setupTempOutputDir(outputDir)
    else:
        # link {sandbox}/dyn-xml to {refWorkspace}/dyn-xml
        dynXmlDir = pathjoin(srcWorkspace, DYN_XML_NAME)

        # Create a local output dir
        mkdirs(outputDir)

    dynXmlLink = pathjoin(sandbox, DYN_XML_NAME)
    _remakeSymLink(dynXmlDir, dynXmlLink)

    # static xml files are always linked to reference workspace
    localXmlDir  = pathjoin(srcWorkspace, LOCAL_XML_NAME)
    localXmlLink = pathjoin(sandbox, LOCAL_XML_NAME)
    _remakeSymLink(localXmlDir, localXmlLink)


def copyWorkspace(newWorkspace, refWorkspace=None, forceCreate=False, mcs=False):
    '''
    Create a copy of a reference workspace by linking to or copying files from
    `refWorkspace`, which defaults to the value of config parameter
    GCAM.RunWorkspace. The copied workspace is the basis for creating sandboxes
    for a Monte Carlo simulation or a non-MCS project.

    :param newWorkspace: (str) the directory to create
    :param refWorkspace: (str) the workspace to link to or copy from
    :param forceCreate: (bool) if True, delete and recreate the sandbox
    :param mcs: (bool) if True, perform setup appropriate for gcammcs trials.
    :return: none
    '''
    _logger.info("Setting up GCAM workspace '%s'", newWorkspace)

    refWorkspace = refWorkspace or getParam('GCAM.RefWorkspace')

    if os.path.lexists(newWorkspace) and os.path.samefile(newWorkspace, refWorkspace):
        raise SetupException("run workspace is the same as reference workspace; no setup performed")

    if mcs and getParamAsBoolean('GCAM.CopyAllFiles'):
        _logger.warn('GCAM.CopyAllFiles = True while running MCS')

    if forceCreate:
        shutil.rmtree(newWorkspace, ignore_errors=True)

    mkdirs(newWorkspace)

    # Spell out rather than computing parameter names to facilitate
    # searching source files for parameter uses.
    toCopy = getParam('GCAM.MCS.WorkspaceFilesToCopy' if mcs else 'GCAM.WorkspaceFilesToCopy')
    for filename in toCopy.split():
        _workspaceLinkOrCopy(filename, refWorkspace, newWorkspace, copyFiles=True)

    toLink = getParam('GCAM.MCS.WorkspaceFilesToLink' if mcs else 'GCAM.WorkspaceFilesToLink')
    for filename in toLink.split():
        _workspaceLinkOrCopy(filename, refWorkspace, newWorkspace, copyFiles=False)

    for filename in ['local-xml', 'dyn-xml']:
        dirname = pathjoin(newWorkspace, filename)
        mkdirs(dirname)


class SetupCommand(SubcommandABC):
    __version__ = '0.1'

    def __init__(self, subparsers):
        kwargs = {'help': '''Setup a scenario by creating modified XML input files.'''}

        super(SetupCommand, self).__init__('setup', subparsers, kwargs)

    def addArgs(self, parser):
        defaultYears = '2015-2100'

        group1 = parser.add_mutually_exclusive_group()
        group2 = parser.add_mutually_exclusive_group()

        parser.add_argument('-b', '--baseline',
                            help='''Identify the baseline the selected scenario is based on.
                                 Note: at least one of --baseline (-b) / --scenario (-s) must be used.''')

        # mutually exclusive with --staticOnly
        group1.add_argument('-d', '--dynamicOnly', action='store_true',
                            help='''Generate only dynamic XML for dyn-xml: don't create static XML.''')

        parser.add_argument('-f', '--forceCreate', action='store_true',
                            help='''Re-create the workspace, even if it already exists.''')

        parser.add_argument('-g', '--group',
                            help='The scenario group to process. Defaults to the group labeled default="1".')

        # mutually exclusive with --dynamicOnly
        group1.add_argument('-G', '--staticOnly', action='store_true',
                            help='''Generate only static XML for local-xml: don't create dynamic XML.''')

        # -m and -M are mutually exclusive
        group2.add_argument('-m', '--modulePath',
                            help='''The path to a scenario definition module. See -M flag for more info.''')

        group2.add_argument('-M', '--moduleSpec',
                            help='''The "dot spec" for the Python module holding the setup classes and
                            a function called 'scenarioClass' or a dictionary called 'ClassMap' which map
                            scenario names to classes. If the function 'scenarioClass' exists, it is
                            used. If not, the 'ClassMap' is used. Default is "{xmlsrc}/subdir/scenarios.py" (if
                            subdir is defined) or "{xmlsrc}/scenarios.py" (if subdir is undefined) under the
                            current ProjectRoot.''')

        parser.add_argument('-p', '--stop', type=int, metavar='period-or-year', dest='stopPeriod',
                            help='The number of the GCAM period or the year to stop after')

        parser.add_argument('-r', '--refWorkspace', default="",
                            help='''A reference workspace to use instead of the value of GCAM.RefWorkspace''')

        parser.add_argument('-R', '--resultsDir',
                            help='The parent directory holding the GCAM output workspaces')

        parser.add_argument('-s', '--scenario',
                            help='''Identify the scenario to run.
                            Note: at least one of --baseline (-b) / --scenario (-s) must be used.''')

        parser.add_argument('-S', '--subdir', default="",
                            help='A sub-directory to use instead of scenario name')

        parser.add_argument('-u', '--useGroupDir', action='store_true',
                            help='Use the group name as a subdir below xmlsrc, local-xml, and dyn-xml')

        parser.add_argument('-x', '--xmlSourceDir',
                            help='''The location of the xmlsrc directory.''')

        parser.add_argument('-X', '--xmlOutputRoot',
                            help='''The root directory into which to generate XML files.''')

        parser.add_argument('-w', '--workspace',
                            help='''The pathname of the workspace to operate on.''')

        # Deprecated or pass to scenario?
        parser.add_argument('-y', '--years', default=defaultYears,
                            help='''Years to generate constraints for. Must be of the form
                            XXXX-YYYY. Default is "%s"''' % defaultYears)

        return parser   # for auto-doc generation


    def run(self, args, tool):
        scenario = args.scenario or args.baseline
        if not scenario:
            raise SetupException('At least one of --baseline (-b) / --scenario (-s) must be used.')

        projectDir = getParam('GCAM.ProjectDir')
        groupName = args.group if args.useGroupDir else ''

        if args.workspace:
            workspace = args.workspace
        else:
            groupDir  = os.path.normpath(pathjoin(projectDir, groupName))
            workspace = pathjoin(groupDir, scenario)

        mcsMode = tool.getMcsMode()
        forceCreate = args.forceCreate or bool(mcsMode)
        if not mcsMode or mcsMode == 'trial':
            createSandbox(workspace, args.refWorkspace, forceCreate=forceCreate, mcsMode=mcsMode)

        xmlSourceDir = args.xmlSourceDir or getParam('GCAM.XmlSrc')

        # TBD: document this
        try:
            if args.moduleSpec:
                module = import_module(args.moduleSpec, package=None)
            else:
                modulePath = args.modulePath or pathjoin(xmlSourceDir, groupName, 'scenarios.py')
                module = loadModuleFromPath(modulePath)

        except Exception as e:
            moduleName = args.moduleSpec or modulePath
            raise SetupException('Failed to load scenarioMapper or ClassMap from module %s: %s' % (moduleName, e))

        try:
            # First look for a function called scenarioMapper
            scenarioMapper = getattr(module, 'scenarioMapper', None)
            if scenarioMapper:
                scenClass = scenarioMapper(scenario)

            else:
                # Look for 'ClassMap' in the specified module
                classMap  = getattr(module, 'ClassMap')
                scenClass = classMap[scenario]

        except KeyError:
            raise SetupException('Failed to map scenario "%s" to a class in %s' % (scenario, module.__file__))

        subdir = args.subdir or scenario
        refWorkspace  = args.refWorkspace or getParam('GCAM.RefWorkspace')
        xmlOutputRoot = args.xmlOutputRoot or workspace

        # When called from gcammcs in 'trial' mode, we only run dynamic setup. When run
        # in 'gensim' mode, we do only static setup.
        args.dynamicOnly = args.dynamicOnly or mcsMode == 'trial'

        if mcsMode == 'gensim':
            args.dynamicOnly = False
            args.staticOnly  = True

        # TBD: Document that all setup classes must conform to this protocol
        obj = scenClass(args.baseline, args.scenario, xmlOutputRoot,
                        xmlSourceDir, refWorkspace, groupName, subdir)

        obj.setup(args)
