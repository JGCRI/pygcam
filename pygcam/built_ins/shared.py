#
# Defines a superclass used by both CO2e and CI2 plugins
#
import os
from pygcam.config import getParam, pathjoin, mkdirs
from pygcam.error import PygcamException
from pygcam.log import getLogger
from pygcam.query import readCsv

_logger = getLogger(__name__)

def log_fmt_df(df):
    return '\n' + df.to_string(formatters={'value': '{:,.2f}'.format}) + '\n'

class PluginCommon(object):
    FLOAT_FORMAT = '%.4f'

    def __init__(self, plugin_name, mapper, years, queryList, is_diff=True):
        self.plugin_name = plugin_name
        self.generated_filename = f"{plugin_name}-generated-files.txt"
        self.mapper = mapper
        self.baseline = mapper.baseline
        self.policy = mapper.scenario
        self.diffsDir = mapper.sandbox_diffs_dir
        self.queryList = queryList

        self.is_diff = is_diff      # CO2e operates on queryResults, not diffs like CI plugin

        self.generated = []         # list of pseudo-query names to process with "diff"

        firstYear, lastYear = self.parse_years(years)
        self.firstYear = firstYear
        self.lastYear = lastYear
        self.yearsOfInterest = range(firstYear, lastYear + 1)
        self.yearCols = [str(y) for y in self.yearsOfInterest]

        self.GHG = None
        self.diffDFs = None
        self.queryDFs = None
        self.lucCO2 = None
        self.normedDFs = None

    def run(self, *args, **kwargs):
        self.verifyResultFiles(self.policy)  # raises error if anything is missing

    def parse_years(self, years):
        # If not passed on command-line, read from config file
        yearsStr = years or getParam('GCAM.Years')
        years = yearsStr.split('-')

        if len(years) != 2:
            raise PygcamException('''Years must be specified as XXXX-YYYY, where XXXX and YYYY
                                     are the first and last years to consider, respectively''')

        firstYear, lastYear = map(int, years)
        return firstYear, lastYear

    def save_pseudo_query_file(self, df, name, source_name,
                               desc='File',
                               float_format=FLOAT_FORMAT):
        """
        Save a CSV file with computed data as a "pseudo-query" file, and
        note its name in the file "diffs/generated-files.txt" so the diff
        command can run on these as well as the queries noted in project.xml.
        :param name: (str) the base name of the file (without the -{scenario}-suffix)
        :param df: (DataFrame) the data to write as a CSV.
        :return: nothing
        """
        from pygcam.query import writeCsv

        csv_path = self.queryPathname(name)
        self.add_generated_filename(name)
        header = f"{desc} generated by {self.plugin_name} plugin from source '{source_name}'"
        writeCsv(df, csv_path, header=header, index=False, float_format=float_format)

    def add_generated_filename(self, name):
        self.generated.append(name)

    def save_generated_filenames(self):
        mkdirs(self.mapper.sandbox_diffs_dir)
        output_file = pathjoin(self.mapper.sandbox_diffs_dir,
                               self.generated_filename, normpath=True)
        with open(output_file, 'w') as f:
            for name in self.generated:
                f.write(name)
                f.write("\n")

    def csv_dir(self):
        mapper = self.mapper
        pathname = mapper.sandbox_diffs_dir if self.is_diff else mapper.sandbox_query_results_dir
        return pathname

    def queryPathname(self, queryName):
        csv_dir = self.csv_dir()

        if self.is_diff:
            pathname = pathjoin(csv_dir, f'{queryName}-{self.policy}-{self.baseline}.csv')
        else:
            pathname = pathjoin(csv_dir, f'{queryName}-{self.policy}.csv')

        return pathname

    def ensureCSV(self, filename):
        'Add a .csv extension to a filename, if there is none. Return the filename.'
        mainPart, extension = os.path.splitext(filename)
        if not extension:
            filename = mainPart + '.csv'

        return filename

    def verifyResultFiles(self, scenario):
        csv_dir = self.csv_dir()

        def resultFileDoesntExist(queryName):
            basename = self.queryPathname(queryName)
            fullname = self.ensureCSV(basename)
            path = pathjoin(csv_dir, fullname)
            _logger.debug("Checking for '%s'", path)
            return None if os.path.lexists(path) else path

        # find missing files, if any
        names = list(filter(resultFileDoesntExist, self.queryList))
        if names:
            names_str = "\n  ".join(names)
            raise PygcamException(f"Query result files are missing in {csv_dir} for '{scenario}':\n  {names_str}")

    # Deprecated - probably, though still used in CI2_plugin.py. Use readQueryResult if that's brought back
    def readDiff(self, query):
        '''
        Read a single query and return a DF holding the results.
        '''
        path = self.queryPathname(query)
        df = readCsv(path)
        return df

    def readDiffs(self):
        '''
        Read the given list of query diff results for the given scenario into DFs.
        Return a dict keyed by query name, with the corresponding DF as the value.
        '''
        _logger.debug("Loading diff results")

        results = {q: self.readDiff(q) for q in self.queryList}
        return results

    def readQueryResult(self, queryName, **kwargs):
        '''
        Read a single query result and return a DF holding the results.
        '''
        path = self.queryPathname(queryName)
        df = readCsv(path, **kwargs)
        return df

    def readQueryResults(self, **kwargs):
        '''
        Read the given list of queries results for the given scenario into DFs.
        Return a dict keyed by query name, with the corresponding DF as the value.
        '''
        _logger.debug("Loading query results")

        results = {q: self.readQueryResult(q, **kwargs) for q in self.queryList}
        return results

    def filterValues(self, df, column, values, complement=False):
        '''
        Restore the columns as such, perform the query, isolate the
        rows of interest, and set the index back to the original value.
        Return a new df with only rows matching the filter criteria.
        '''
        if not hasattr(values, '__iter__'):
            values = [values]

        query = "%s %s in %s" % (column, 'not' if complement else '', values)
        df = df.query(query)
        return df

    def sumDiffs(self, df, col=None, values=None, complement=False):
        '''
        Sum the year-by-year differences and then sum across years. If col and
        values are provided, only rows with (or without, if complement is True)
        one of the given values in the given column will be included in the sum. The
        parameter startYear allows fuel changes to be counted starting at the shock
        year rather than counting the values interpolated from the baseline to the
        value in the first shock year.
        '''
        if col and values:
            df = self.filterValues(df, col, values, complement=complement)

        yearTotals = df[self.yearCols].sum() # sum columns
        total = yearTotals.sum()        # sum across years
        return total
