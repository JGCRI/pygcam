'''
.. Copyright (c) 2019-2023 Richard Plevin
   See the https://opensource.org/licenses/MIT for license details.
'''
import os
from .error import PygcamException, FileMissingError
from .log import getLogger

_logger = getLogger(__name__)

_csvCache = {}

def readCachedCsv(filename, skiprows=1, cache=False):
    """
    Read a CSV file of the form generated by GCAM batch queries, i.e., skip one
    row and then read column headings and data. Optionally drop all years outside
    the `years` given. Optionally, linearly interpolate annual values between
    time-steps.

    :param filename: (str) the path to a CSV file
    :param skiprows: (int) the number of rows to skip before reading the data matrix
    :param cache: (bool) If True, file will be sought in, and saved to, a CSV cache.
       The "raw" file data is cached, so if called with different processing args,
       the same initial DataFrame is used, but it will be processed correctly.
    :return: (DataFrame) the data read in, processed as per arguments
    """
    import pandas as pd

    found = False

    pathname = os.path.abspath(filename)

    if cache and pathname in _csvCache:
        _logger.debug("Found %s in CSV cache", filename)
        df = _csvCache[pathname]
        found = True

    else:
        try:
            _logger.debug("Reading %s", pathname)
            df = pd.read_table(pathname, sep=',', skiprows=skiprows, index_col=None)

        except IOError as e:
            raise FileMissingError(pathname, e)

        except Exception as e:
            raise PygcamException(f'Error reading {filename}: {e}')

    # Cache a copy, unless it was already in the cache
    if cache and not found:
        _csvCache[pathname] = df.copy()

    return df
