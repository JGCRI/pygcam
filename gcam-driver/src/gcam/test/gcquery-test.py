#!usr/bin/env python
"""Test the gcam queries used by the automation system on a specified db file

Usage:  gcquery-test.py <dbfile>
"""

import sys
import os.path
import unittest

## set dbfile to use for testing
try:
    dbfile = sys.argv[1] 
except IndexError:
    sys.exit('Error: no dbfile specified.\nUsage:  %s <dbfile>\n'%sys.argv[0])
    



## enable this code to run from the gcam/test/ directory
sys.path.append('../..')

from gcam import util
from gcam.modules import GlobalParamsModule
from gcam.water import waterdisag

#Test Class
class testQueries(unittest.TestCase):
	def setUp(self):		
	## Set up the global parameters module (which is used by some of the
	## utility functions).
		self.genparams = {"ModelInterface": "/people/ledn787/ModelInterface-dbxml/ModelInterface.jar",
				'inputdir': './../../../input-data', 
				'rgnconfig': 'rgnchn',
				'DBXMLlib': "/people/link593/lib"}
 
		self.global_params = GlobalParamsModule({})
		for key in self.genparams.keys():
    			self.global_params.addparam(key, self.genparams[key])
	
		self.global_params.run()

				
		self.queryfiles = ['batch-land-alloc.xml', 'batch-population.xml', 'batch-water-ag.xml',
					'batch-water-dom.xml', 'batch-water-elec.xml', 'batch-water-livestock.xml',
					'batch-water-mfg.xml', 'batch-water-mining-alt.xml']
		## add the directory path to the query files
		self.querydir  = '../../../input-data/'
		self.queryfiles = map(lambda file: self.querydir + file, self.queryfiles)
		self.dbfile = dbfile #This is the dbfile I'm using in my test directory. 
		
		self.outfiles = ['batch-land-alloc.csv', 'batch-population.csv', 'batch-water-ag.csv',
				'batch-water-dom.csv', 'batch-water-elec.csv', 'batch-water-livestock.csv',
				'batch-water-mfg.csv', 'batch-water-mining.csv']

		self.outfiles = map(lambda file: './sample-out/' + file, self.outfiles)
		
	#Variables for CSV files:
		self.tot_regions = 65 #from RgnNames.txt
		self.num_drops = 2 	#from drop-regions.txt
		self.gcam_regions = 32	
		self.province_names = 33#From rgn-name-translation.csv
		
		self.gis_regions = 64	#from gis2000.csv
	
			
		self.nyears = 20 	#Number of years included in output csvs
			

	def testInit_rgn_tables(self):
		"""Check that global variables generated by init_rgn_tables exist and are
		of the correct type."""
		## set up the region tables for the waterdisag module
		rgnconfdir = os.path.join(self.genparams['inputdir'],self.genparams['rgnconfig'])
		waterdisag.init_rgn_tables(rgnconfdir)
		
				
		##Test global variable type and length (ensure that it correctly corresponds to csv files
		self.assertIs(type(waterdisag._regions_ordered), list)
						
		for table in (waterdisag._gis2000, waterdisag._bfracFAO2005, waterdisag._gfracFAO2005, waterdisag._gcam_rgn_translation):				self.assertIs(type(table), dict)
		
		#Check lengths
		self.assertEqual(len(waterdisag._regions_ordered), self.tot_regions - self.num_drops)	
		self.assertEqual(len(waterdisag._gcam_rgn_translation), self.province_names)
		self.assertEqual(len(waterdisag._gis2000),self.gis_regions) 
		self.assertEqual(len(waterdisag._bfracFAO2005), self.gcam_regions)		
		self.assertIs(len(waterdisag._gfracFAO2005), self.gcam_regions)
		

	def testProc_wdnonag(self):
		"""Test the function proc_wdnonag to ensure correct tables are returned."""
		#Query the specified database			
		#of_new = util.gcam_query(self.queryfiles, self.dbfile, self.querydir, self.outfiles)

		### Process the queries
		wd_elec = waterdisag.proc_wdnonag('./sample-out/batch-water-elec.csv', './sample-out/final_wd_elec.csv')
		wd_mfg  = waterdisag.proc_wdnonag('./sample-out/batch-water-mfg.csv', './sample-out/final_wd_mfg.csv')
		wd_min  = waterdisag.proc_wdnonag('./sample-out/batch-water-mining.csv', './sample-out/final_wd_mining.csv') 
		wd_dom  = waterdisag.proc_wdnonag('./sample-out/batch-water-dom.csv', './sample-out/final_wd_dom.csv')
		
		#Test the output tables for correct type and length 
		for table in (wd_elec, wd_mfg, wd_min, wd_dom):
			self.assertIs(type(table), dict)
			for region in table:
				data = table[region]
				data = data.split(',')
				self.assertEqual(len(data), self.nyears)
		
		self.assertEqual(len(wd_elec), self.tot_regions - self.num_drops -1) #For some reason China is excluded from queries; normal?
		self.assertEqual(len(wd_dom), self.tot_regions - self.num_drops -1) 
		self.assertEqual(len(wd_mfg), self.tot_regions - self.num_drops -1)
		self.assertEqual(len(wd_min), self.gcam_regions)
		
	def testProc_wdlivestock(self):
		"""Test the function proc_wdlivestock to ensure correct tables are returned."""
		## process livestock water demand
		wd_liv  = waterdisag.proc_wdlivestock('./sample-out/batch-water-livestock.csv', './sample-out/final_wd_liv.csv', './sample-out/rgn_tot_withd_liv.csv')
		
		self.assertIs(type(wd_liv), dict)
		self.assertEqual(len(wd_liv), (self.gcam_regions-1)*5 -1)	#5 types of livestock in 31 regions (no Taiwan), minus header 		
		for region in wd_liv: 
			data = wd_liv[region]
			self.assertEqual(len(data), self.nyears)


#No input file for this next function
#	def testProc_irr_share(self):
#		"""Test the function proc_irr_share to ensure correct tables are returned."""
		## process ag water demand
#		irrS    = waterdisag.proc_irr_share('./sample-out/irrigation-frac.csv', './sample-out/irrS.csv')
	
	#No tables returned; will modify functions to return tables if requested
	def testProc_ag_area(self):
		"""Test the function proc_ag_area to ensure correct tables are returned."""
		## no tables returned by these next two.  Maybe we should return them for consistency?
		waterdisag.proc_ag_area('./sample-out/batch-land-alloc.csv', './sample-out/final_ag_area.csv')

	
	def testProc_ag_vol(self):
		"""Test the function proc_ag_vol to ensure correct tables are returned."""
		waterdisag.proc_ag_vol('./sample-out/batch-water-ag.csv', './sample-out/final_wd_ag.csv')


	
		
if __name__ == '__main__': 
	testQueries.dbfile = sys.argv.pop()
	unittest.main()


